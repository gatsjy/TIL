DROP TABLE SUBQUERY_T1 PURGE;
DROP TABLE SUBQUERY_T2 PURGE;
DROP TABLE SUBQUERY_T3 PURGE;

CREATE TABLE SUBQUERY_T1 AS
SELECT LEVEL AS C4, CHR(65+MOD(LEVEL,26)) AS C5, LEVEL+99999 AS C6
   FROM DUAL
 CONNECT BY LEVEL <= 250000
 ;
 
 -- 250000 개의 데이터를 생성 한 후 동일한 테이블 값을 6번 반복하여 복사함
 BEGIN
    FOR I IN 1..6 LOOP
        INSERT INTO SUBQUERY_T1 SELECT * FROM SUBQUERY_T1;
        COMMIT;
    END LOOP;
END;
/

-- 각 컬럼에 인덱스 생성 및 통계정보를 수집
EXEC dbms_stats.gather_table_stats(OWNNAME=>'SCOTT',TABNAME=>'SUBQUERY_T1',CASCADE=>TRUE,ESTIMATE_PERCENT=>100);

CREATE INDEX SUBQUERY_T1_IDX_01 ON SUBQUERY_T1 (C4, C5);
CREATE INDEX SUBQUERY_T1_IDX_02 ON SUBQUERY_T1 (C5);

< SUBQUERY_T2>

-- 생성요건
- 테이블 데이터 건수는 500000 로우
- 컬럼 C1은 값의 종류가 500000 가지 즉, Unique한 값임
- 컬럼 C2는 값의 종류가 26가지
- 컬럼 C3는 값의 종류가 50000 가지이며, 100000 부터 순차적으로 증가
- 컬럼 C4는 값의 종류가 26가지

-- 테이블 생성
CREATE TABLE SUBQUERY_T2 AS
SELECT LEVEL AS C1, CHR(65+MOD(LEVEL,26)) AS C2, LEVEL+99999 AS C3, CHR(65+MOD(LEVEL,26)) AS C4 
   FROM DUAL
 CONNECT BY LEVEL <= 500000;
 
 -- 각 컬럼에 인덱스 생성 및 통계정보 수집
 EXEC dbms_stats.gather_table_stats(OWNNAME=>'SCOTT',TABNAME=>'SUBQUERY_T2',CASCADE=>TRUE,ESTIMATE_PERCENT=>100);
 
 CREATE INDEX SUBQUERY_T2_IDX_01 ON SUBQUERY_T2 ( C2, C1);
 ALTER TABLE SUBQUERY_T2 ADD CONSTRAINTS PK_SUBQUERY_2 PRIMARY KEY (C1);
 
 < SUBQUERY_T3 >
 
 -- 생성조건
 - 테이블 데이터 건수 500000 로우
 - 컬럼 C1은 값의 종류가 500000가지이며, Unique한 값을 가지도록 생성
 - 컬럼 C2는 값의 종류가 26가지가 되도록 생성
 - 컬럼 C3는 값의 종류가 500000가지이며, 100000 부터 순차적으로 증가하도록 생성
 
 CREATE TABLE SUBQUERY_T3 AS
 SELECT LEVEL AS C1, CHR(65+MOD(LEVEL,26)) AS C2, LEVEL+99999 AS C3
    FROM DUAL
 CONNECT BY LEVEL <= 500000;
 
 -- 각 컬럼에 인덱스 생성 및 통계정보 수집
 EXEC dbms_stats.gather_table_stats(OWNNAME=>'SCOTT',TABNAME=>'SUBQUERY_T3',CASCADE=>TRUE,ESTIMATE_PERCENT=>100);
 
 CREATE INDEX SUBQUERY_T3_IDX_01 ON SUBQUERY_T2 ( C1, C2);
 ALTER TABLE SUBQUERY_T3 ADD CONSTRAINTS PK_SUBQUERY_3 PRIMARY KEY (C1);