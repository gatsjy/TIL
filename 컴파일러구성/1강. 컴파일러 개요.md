* 학습개요
- 번역기의 관점에서 컴파일러와 인터프리터를 비교해 본다. 

* 학습목표
1. 컴파일러의 정의 및 기능에 대해 이해할 수 있다.
2. 컴파일러와 인터프리터의 특성을 설명할 수 있다.
3. 컴파일러의 논리적 구조 및 물리적 구조를 이해할 수 있다.
4. 간단한 컴파일러의 예를 통하여 전반적인 커파일러의 구조를 설명할 수 있다.

* 주요용어
- 원시프로그램 : 번역기에 입력되는 프로그램
- 목적프로그램 : 번역기에서 출력되는 프로그램
- 어셈블러 : 어셈블리어로 작성된 프로그램을 그에 대응하는 기계어로 번역하여 주는 번역기
- 컴파일러 : 고급언어로 작성된 프로그램을 저급언어로 작성된 프로그램으로 번역 해주는 번역기
- 프리프로세서 : 프로그래밍 언어에 유용한 기능들을 추가하여 언어를 확장시켜주는 역할을 하는 것으로서, 원시언어와 목적언어가 모두 고급언어인 번역기
- 인터프리터 : 고급언어를 입역으로 받아들여서 번역과 동시에 실행을 한 후, 그 결과를 출력하기 때문에, APL, SNOBOL, 등과 같은 대화용 언어를 구현할 경우 사용
- 디버깅 : 프로그램의 오류를 발견하고 그 원인을 수정하는 작업
- 이식성 : 원시 프로그램을 다른 기종으로 옮기는 것이 얼마나 용이한가를 나타내는 정도
- 번역기 : 하나의 프로그래밍 언어로 작성된 프로그램을 입력으로 하며 그와 동등한 의미를 갖는 다른 프로그래밍 언어로 된 프로그램을 출력하는 하나의 프로그램
- 토큰 : 컴파일러나 어셈블러 등의 처리기에서 사용되는 어휘 분석의 최소 단위이다. 즉 예약어, 상수, 연산자, 식별자, 구분자 등이다.
- 어휘분석기(스캐너) : 원시 프로그램을 읽어 들여 토큰 이라는 의미있는 문법적 단위로 분리하여 출력하는 프로그램
- 구문분석기(파서) : 어휘분석 단계의 결과인 토큰들을 받아, 이 토큰들이 주어진 문법에 맞는지 검사하는 프로그램
- 파스트리 : 토큰들을 단말 노드로 하여 트리 형태로 표현한 것
- 구문트리 : 파스트리에서 불필요한 정보들을 제거하고, 꼭 필요한 정보들만으로 구성된 트리
- 의미분석 : 구문트리에 대하여 어떠한 의미와 기능을 하는 것인지를 분석하고, 이러한 기능이 올바르게 수행될 수 있도록 환경을 구성한다.
- 코드최적화 : 코드를 좀더 효울적으로 만들어 코드 실행시 기억공간이나 실행시간을 절약한다.
- 지역최적화 : 부분적인 관점에서 일련의 비효율적은 코드를 구분해내고, 좀더 효율적인 코드로 수정한다.
- 전역최적화 : 지역최적화와는 달리 부분적인 관점이 아니라, 전체적인 관점에서 효율적인 코드로 수정하는 방법
- 패스 : 컴파일러를 구현할 때 여러 논리적 단계들을 모아서 하나의 물리적 모듈로 묶은 것

* 강의 시작
- 컴파일러의 개념?
언어를 번역한다? 번역기의 개념

컴파일러 기법
- 번역 후 실행
> 효율적
> 반복문 처리에 효과 
-> 인터프리터의 경우에는 번역하고 실행하고 번역하고 실행하고... 컴파일러는 이미다 번역을 해놨기 때문에 바로 실행만하면된다!
> 큰 지억장소 요구
> FORTRAN, COBOL, BASIC, PASCAL, C, C++, JAVA

인터프리터 기법
- 번역과 실행
> 실행기간이 길다.
> 사용자와 대화식
> 융통성
> LISP, APL, SNOBOL

과목개설이유
> 컴파일러 구현의 어려움
> FORTRAN 컴파일러구현 

컴파일러의 논리적구조
프로그램
1 어휘분석
2 구문분석
3 의미분석
4 중간코드
5 최적화
6 목적코드 생성

1. 어휘분석
-> 기본어휘가 문법에 맞는지 분석
-> 어휘를 토큰으로 변환
-> 연산자, 식별자, 예약어, 구분자, 상수
-> 어휘분석 : Lexical Analysis, Scan
-> 어휘분석기 : Lexical Analyzer, Scanner

2. 구문분석
-> 구문이 문법에 맞는지 분석한다.
-> 분석결과를 파스트리로 출력
-> 구문분석 : Syntax Analysis, Parse
-> 구문분석기 : Syntax Analyzer

3. 의미분석
-> 파스트리에 의미부여
-> 실행 전 사전작업
-> 자료구조정의, 혼합형연산, 기호표
-> ABC := E*3.14 + ABC/E;

4. 중간코드
-> 최적화를 위한 중간단계
-> 후위표현 : Quadruple
-> 3 주소코드
-> U 코드
-> 문법지시적표현

5. 최적화
-> 효율화
-> 수행시간 최소화
-> 기억공간 최소화

6. 목적코드 생성
-> 사용할 레지스터의 수
-> 계산과정
-> 명령어 종류

3. 논리적구조/물리적구조
- 컴파일러의 논리적 구조와 물리적구조

1-패스 컴파일러(과거의 개념)
효율성(기계코드 변환)
실행속도가 빠르다.
backpatching IF (A OR B) AND C THEN

2-패스 컴파일러(현대적 개념)
이식성(Portability)
기계독립적, 최적화
기억장소 절약
기계코드 표현 제약
실행속도가 느리다.

4. 컴파일러 실행 예
- 연산자우선순위 이용
- 과정만 설명


